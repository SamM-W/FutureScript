//Compiled by the FutureScript compiler (v2.1.6)
import { range, log, validateIsOf } from "file://C:\\Gists\\EPQ-FutureProgrammingLanguages\\NewLang\\library\\Implementations.js";
var regex =  "abc?[12]" ; class StringReader { constructor ( input ) { this.getInput = (input) => this.input; this.setInput = (input) => {this.input = input}; this.input = input; } ; peek ( ) { return this . input . substring ( 0 , 1 ) ; } ; consume ( ) { this . input =  this . input . substring ( 1 ) ; } ; isEmpty ( ) { return this . input . length !== 0 ; } ; } ;  class Token { constructor ( ) {    this._composure = {"base":{"consume":{"procedure":false}}}; this._traits = []; this.getTrait = (traitType) => { for (var i = 0; i < this._traits.length; i++) { if (this._traits[i] instanceof traitType) { return this._traits[i]; } } return null; }; this.getTraits = (traitType) => { var all = []; for (var i = 0; i < this._traits.length; i++) { if (this._traits[i] instanceof traitType) { all.push(this._traits[i]); } } return all; }; this.addTrait = (trait) => { this._traits.push(trait); for (const functionName in this._composure.base) { if (trait[functionName]) { const isProcedure = this._composure.base[functionName].procedure; const traitFunction = trait[functionName]; const next = this[functionName]; this[functionName] = (...args) => { if (isProcedure) { next.apply(trait, [...args, this]); traitFunction.apply(trait, [...args, this]); } else { return traitFunction.apply(trait, [...args, this, next]); } } } } trait.onCompose?.(this); }; } ; consume ( reader ) { return this . testToken ( reader ) !== null ; } ; testToken ( reader ) { return null ; } ; } ;  class CharToken extends Token { constructor ( char ) { validateIsOf ( char , "string" ) ; this.getChar = (char) => this.char; this.setChar = (char) => {this.char = char}; this.char = char; this._composure = {"base":{}}; this._traits = []; this.getTrait = (traitType) => { for (var i = 0; i < this._traits.length; i++) { if (this._traits[i] instanceof traitType) { return this._traits[i]; } } return null; }; this.getTraits = (traitType) => { var all = []; for (var i = 0; i < this._traits.length; i++) { if (this._traits[i] instanceof traitType) { all.push(this._traits[i]); } } return all; }; this.addTrait = (trait) => { this._traits.push(trait); for (const functionName in this._composure.base) { if (trait[functionName]) { const isProcedure = this._composure.base[functionName].procedure; const traitFunction = trait[functionName]; const next = this[functionName]; this[functionName] = (...args) => { if (isProcedure) { next.apply(trait, [...args, this]); traitFunction.apply(trait, [...args, this]); } else { return traitFunction.apply(trait, [...args, this, next]); } } } } trait.onCompose?.(this); }; } ; testToken ( reader ) { var peek =  reader . peek ( ) ; if ( peek === char ) { reader . consume ( ) ; return peek ; } ; } ; } ; function testPseudoRegex ( regex , string ) { var reader =  new StringReader ( regex , string ) ; function readToken ( ) { var peek =  reader . peek ( ) ; return new CharToken ( peek ) ; } ; while ( ! reader . isEmpty ( ) ) { readToken ( ) ; } ; console . log ( tokens ) ; return [ ] ; } ; function assertTestEq ( regex , test , expect ) { var result =  testPseudoRegex ( regex , test ) ; if ( result !== expect ) { throw `Test failed, expected ${expect} but got ${result}, for /${regex}/, testing against ${test}` ; } ; } ; assertTestEq ( regex , "ab1" , true ) ; assertTestEq ( regex , "abc2" , true ) ; assertTestEq ( regex , "gbc1" , false ) ; assertTestEq ( regex , "abc11" , true ) ; assertTestEq ( regex , "abca1" , false ) ;