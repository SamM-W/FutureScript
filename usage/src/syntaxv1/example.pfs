//This is an example piece of code used for testing the pfs transpiler,
//Semicolons at the end of lines are required due to limitations of the parser
//The result is a javascript file

class Hat {
    //A 'property' keyword is used to automatically generate getters and setters
    //This means that later on the way that these properties is accessed can be modified
    constructor(property Hat type) {
        console.log("The hat property has been set to: " + this.type);
    }
}

class HatWearer {
    constructor() {
        //Type annotations can also be applied to properties of the current object
        Hat this.currentHat = undefined;
    }

    wear(Hat hat) {
        this.currentHat = hat;
        this.processWearing(hat);
    }

    abstract processWearing(hat);
}

class MoneyOwner {
    constructor(property number accountValue, accountName) {
        console.log(accountName);
    }
}

composed class Person(HatWearer, MoneyOwner) {
    //Another example of a property usage, which reduces boilerplate code
    constructor(property String firstname) {
    }

    //Composed classes can provide implementations for a specific super type
    implementation HatWearer.processWearing(Hat hat) {
        console.log("Im wearing a hat!" + impl.name + " is wearing a " + this.name + " hat");
    }
}

function testingGenericFunction(Hat hat) {
    console.log(hat.type);
}

function testingGenericFunction(Hat hat1, Hat hat2, Hat hat3, anytype) {
    console.log(hat.type);
}

//Use of more java style explicit type definition (These serve as hints to the IDE about the variable, when compiled they are reverted to a var)
Person person = new Person("John");
//But the more flexible var keyword is also allowed
var hatWearer = person.as(HatWearer);
hatWearer.wear(new Hat("Bowler"));
var exampleTestJSON = {hi : 2};

console.log(hatWearer.currentHat);
