composed class Customer {
    constructor(property String name) {
    }
}

composed class Animal {
    constructor(property String name) {
    }
}

composed class Greetable {
    constructor() {
    }

    greet() {
        //Invoke getName on the composed class
        String nameToGreet = comp.getName();
        console.log("Hello " + nameToGreet);
    }

    //Require that the composed class has a getName method
    //This is like requiring a parent class, but instead is just definining an interface needed
    expect getName();
}

//Functionality is seperated from the data, this means that there is no coupling,
//but importantly it still remains a single object that can be moved around
Composed<Customer, Greetable> greetableCustomer = new Composed(new Customer("Charlie"), new Greetable());
Composed<Animal, Greetable> greetableAnimal = new Composed(new Animal("Cosmo"), new Greetable());

greetableCustomer.greet();
greetableAnimal.greet();